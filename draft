Semaphore bonus, thread-less style:

Init values (addresses to NULL). Includes semaphores (if NULL at exit, do not attempt a close).

Init args. Print usage or error.

Init shared semaphores. Create all shared semaphores. Make sure they can be created, otherwise, exit.

Make sure signal semaphores CAN be created, if not, exit.
These semaphores are not created, but they will be eventually. If they already exist and we don't have perms, error.

Fork in a loop. If any fork fails, create start semaphore and create stop semaphore. Forks will exit. Waitpid. Then error out.

After fork in parent:

	Init supervisor
	Create start sem
	Launch supervisor routine
	Cleanup supervisor
	Waitpid
	Cleanup program
	Return

After fork in child:

	Init philo
	Try for open start sem in an infin loop
	Launch philo routine
	Cleanup philo
	Return







sem_open strategy, for thread-less communication:

Info that needs to be communicated:

1. When all philos are ready, for supervisor to tell them all to start
	-> Array
2. When to start (supervisor sets)
3. When a philo is dead
4. When a philo is stuffed
	-> Array
5. Whether the sim is stopped
6. If any philo ran into a critical error anywhere

For supervisor logic of checking on ready sem and stuffed sem:
These sems exist in arrays of num_philos.
The array will contain the name of the philo's sem and a bool.
It will be checked in a loop.
If the bool is false, check if sem_open can be done. If so, close it right away and set bool to true.
If bool is true, just increment a value.
When the value reaches num_philos during an entire loop, everyone's ready/stuffed.




For all other 4 sems, 2 of them go supervisor->philo, the other 2 go the other way.

Both the sender and the receiver need to know the name of the sem, to attempt to open it or create it.
The name has to be decided in advance, and thus malloc'd. It will be cloned in the forks.

To avoid vulnerability problems (or make it a bit harder at least) I can create a timestamp hash and put it in the semaphore's name. Or I can just shrug and say fuck it. (probably the latter)




18/02/2026

Update:

Code almost written. Supervisor logic and philo logic to be written.
Philo needs gettime + routine

Supervisor needs routine (very little to write)

The way I'm writing the program is no good, though, for now.
Basically supervisor has no way of knowing which philo died.
Also, philos have no way of telling the supervisor when they are scheduled to die (like the way I did it in the base program).
So the only way to do it the way I'm currently doing it is for philosophers themselves to realize that they will die during a usleep, stop themselves in advance, usleep of the difference, and print their own death message.
But this is way less elegant than the way I did it the first time.
Thus, I need to find a better way if there is one...
But how can philos, which are in an entirely different process, tell their time to death to the main process? They don't share any memory and there are no signals.


One added thing: in case of critical error (e.g I can't post stop) I can kill all the philo pids. Need to add this.


20/02/2026


Small problem here. Philos anticipate their own death. That's fine. Except it's not if they die while waiting on a fork, because then they can't check for their own death.

Philos handling their death themselves is just pretty stupid and doesn't really work.

I have to COMPLETELY change the way my logic works, sadly.

The SUPERVISOR has to handle philo deaths, not philo themselves.

Philos just do their fucking thing, supervisor handles all the rest.

Problem : Philos can't fucking tell the supervisor their time-of-death, unlike in base program.

I only have fucking semaphores to carry information, it's just shit.

There are 2 solutions to this:
1. Philos have their own fucking mini supervisor supervising them and just them, in a separate thread. It will just check on their time of death and signal that they're dead if they are - maybe print death itself, why not. Big supervisor just sets a stop value, I guess (or not even, fuck it). This requires pthread, at long last.
2. I stubbornly refuse ONCE AGAIN to use pthread if I can avoid it at all, and I go the other option... Philosophers tell the supervisor their time of death and that's it. But how? They just create and remove a semaphore over and over again whenever they eat, and the supervisor will look for it to know that a philo just ate and to update its time_of_death. So the supervisor can't usleep, he has to always be looping asap because any delay in it noticing the sem is a delay in the time_of_death update. Note that with this solution, we run into problems if the amount of philos is so great and time_to_eat/to_sleep are so short that the philo will try to create its "just ate" semaphore faster than the supervisor can acknowledge and clear it. In other words, this is a BAD solution.

Hence, we need threads. There's just no way not to do this project without them.
So I might as well just go for full threads and give up on the stupid sem_open business.

This means recoding almost everything.




New version with threads and without sem_open bullshit:
- Parent needs to check
	- Stuffed counter (that's one thread)
	- Any death (that's another thread)
- Philo logic is exactly the same as base program
	- Except since parent cannot read time.death value, there has to be a mini supervisor
	- Mini supervisor checks for death value (and that's all)
	- Another supervisor needs to check for stop sem (sem_wait, so has to be a separate thread)


One more thing, when it comes to who posts which sem...
Either mini-supervisors only communicate with chief supervisor
Or mini-supervisors take matters into their own hands by communicating with other supervisors and printing death

In option #1
- Mini will only post death sem (array), big supervisor needs as many threads just to wait on that sem (this is ridiculous, but theoretically possible)
In option #2
- Mini will post, in a loop, stop sem (num_philo + 1 times) so that parent + all philo children waiting on it know to stop
- Mini will also announce its philo's death


- Parent
- Parent thread #1
- Parent thread #2
- Philo
- Philo thread #1
	- Check time_of_death in loop. Post death if philo died.
	- Death sem has to be in an array to know which philo died
- Philo thread #2










































