Semaphore bonus, thread-less style:

Init values (addresses to NULL). Includes semaphores (if NULL at exit, do not attempt a close).

Init args. Print usage or error.

Init shared semaphores. Create all shared semaphores. Make sure they can be created, otherwise, exit.

Make sure signal semaphores CAN be created, if not, exit.
These semaphores are not created, but they will be eventually. If they already exist and we don't have perms, error.

Fork in a loop. If any fork fails, create start semaphore and create stop semaphore. Forks will exit. Waitpid. Then error out.

After fork in parent:

	Init supervisor
	Create start sem
	Launch supervisor routine
	Cleanup supervisor
	Waitpid
	Cleanup program
	Return

After fork in child:

	Init philo
	Try for open start sem in an infin loop
	Launch philo routine
	Cleanup philo
	Return







sem_open strategy, for thread-less communication:

Info that needs to be communicated:

1. When all philos are ready, for supervisor to tell them all to start
	-> Array
2. When to start (supervisor sets)
3. When a philo is dead
4. When a philo is stuffed
	-> Array
5. Whether the sim is stopped
6. If any philo ran into a critical error anywhere

For supervisor logic of checking on ready sem and stuffed sem:
These sems exist in arrays of num_philos.
The array will contain the name of the philo's sem and a bool.
It will be checked in a loop.
If the bool is false, check if sem_open can be done. If so, close it right away and set bool to true.
If bool is true, just increment a value.
When the value reaches num_philos during an entire loop, everyone's ready/stuffed.




For all other 4 sems, 2 of them go supervisor->philo, the other 2 go the other way.

Both the sender and the receiver need to know the name of the sem, to attempt to open it or create it.








