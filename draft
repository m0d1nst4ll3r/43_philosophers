Semaphore bonus, thread-less style:

Init values (addresses to NULL). Includes semaphores (if NULL at exit, do not attempt a close).

Init args. Print usage or error.

Init shared semaphores. Create all shared semaphores. Make sure they can be created, otherwise, exit.

Make sure signal semaphores CAN be created, if not, exit.
These semaphores are not created, but they will be eventually. If they already exist and we don't have perms, error.

Fork in a loop. If any fork fails, create start semaphore and create stop semaphore. Forks will exit. Waitpid. Then error out.

After fork in parent:

	Init supervisor
	Create start sem
	Launch supervisor routine
	Cleanup supervisor
	Waitpid
	Cleanup program
	Return

After fork in child:

	Init philo
	Try for open start sem in an infin loop
	Launch philo routine
	Cleanup philo
	Return







sem_open strategy, for thread-less communication:

Info that needs to be communicated:

1. When all philos are ready, for supervisor to tell them all to start
	-> Array
2. When to start (supervisor sets)
3. When a philo is dead
4. When a philo is stuffed
	-> Array
5. Whether the sim is stopped
6. If any philo ran into a critical error anywhere

For supervisor logic of checking on ready sem and stuffed sem:
These sems exist in arrays of num_philos.
The array will contain the name of the philo's sem and a bool.
It will be checked in a loop.
If the bool is false, check if sem_open can be done. If so, close it right away and set bool to true.
If bool is true, just increment a value.
When the value reaches num_philos during an entire loop, everyone's ready/stuffed.




For all other 4 sems, 2 of them go supervisor->philo, the other 2 go the other way.

Both the sender and the receiver need to know the name of the sem, to attempt to open it or create it.
The name has to be decided in advance, and thus malloc'd. It will be cloned in the forks.

To avoid vulnerability problems (or make it a bit harder at least) I can create a timestamp hash and put it in the semaphore's name. Or I can just shrug and say fuck it. (probably the latter)




18/02/2026

Update:

Code almost written. Supervisor logic and philo logic to be written.
Philo needs gettime + routine

Supervisor needs routine (very little to write)

The way I'm writing the program is no good, though, for now.
Basically supervisor has no way of knowing which philo died.
Also, philos have no way of telling the supervisor when they are scheduled to die (like the way I did it in the base program).
So the only way to do it the way I'm currently doing it is for philosophers themselves to realize that they will die during a usleep, stop themselves in advance, usleep of the difference, and print their own death message.
But this is way less elegant than the way I did it the first time.
Thus, I need to find a better way if there is one...
But how can philos, which are in an entirely different process, tell their time to death to the main process? They don't share any memory and there are no signals.


One added thing: in case of critical error (e.g I can't post stop) I can kill all the philo pids. Need to add this.


20/02/2026


Small problem here. Philos anticipate their own death. That's fine. Except it's not if they die while waiting on a fork, because then they can't check for their own death.

Philos handling their death themselves is just pretty stupid and doesn't really work.

I have to COMPLETELY change the way my logic works, sadly.

The SUPERVISOR has to handle philo deaths, not philo themselves.

Philos just do their fucking thing, supervisor handles all the rest.

Problem : Philos can't fucking tell the supervisor their time-of-death, unlike in base program.

I only have fucking semaphores to carry information, it's just shit.

There are 2 solutions to this:
1. Philos have their own fucking mini supervisor supervising them and just them, in a separate thread. It will just check on their time of death and signal that they're dead if they are - maybe print death itself, why not. Big supervisor just sets a stop value, I guess (or not even, fuck it). This requires pthread, at long last.
2. I stubbornly refuse ONCE AGAIN to use pthread if I can avoid it at all, and I go the other option... Philosophers tell the supervisor their time of death and that's it. But how? They just create and remove a semaphore over and over again whenever they eat, and the supervisor will look for it to know that a philo just ate and to update its time_of_death. So the supervisor can't usleep, he has to always be looping asap because any delay in it noticing the sem is a delay in the time_of_death update. Note that with this solution, we run into problems if the amount of philos is so great and time_to_eat/to_sleep are so short that the philo will try to create its "just ate" semaphore faster than the supervisor can acknowledge and clear it. In other words, this is a BAD solution.

Hence, we need threads. There's just no way not to do this project without them.
So I might as well just go for full threads and give up on the stupid sem_open business.

This means recoding almost everything.




New version with threads and without sem_open bullshit:
- Parent needs to check
	- Stuffed counter (that's one thread)
	- Any death (that's another thread)
- Philo logic is exactly the same as base program
	- Except since parent cannot read time.death value, there has to be a mini supervisor
	- Mini supervisor checks for death value (and that's all)
	- Another supervisor needs to check for stop sem (sem_wait, so has to be a separate thread)


One more thing, when it comes to who posts which sem...
Either mini-supervisors only communicate with chief supervisor
Or mini-supervisors take matters into their own hands by communicating with other supervisors and printing death

In option #1
- Mini will only post death sem (array), big supervisor needs as many threads just to wait on that sem (this is ridiculous, but theoretically possible)
In option #2
- Mini will post, in a loop, stop sem (num_philo + 1 times) so that parent + all philo children waiting on it know to stop
- Mini will also announce its philo's death


BTW: Parent only needs 1 thread, parent itself waits for stop. Parent does not look for deaths (mini supervisors do this), only parent thread (#1) looks for stuffed condition (waits in a loop). The stuffed supervisor will simply set stop and exit.
Due to the fact that the stuffed supervisor could be waiting forever, as part of the main thread's exit process, it will have to manually post all the stuffed sems and pthread_join.


- Parent
	- Looks for 
- Parent thread #1
- Philo
	- Normal routine, does loop, locks print, forks, think eat sleep
	- Updates time_of_death upon eating
	- Looks at stop value on printing
	- Works like basic philo
- Philo thread #1
	- Check time_of_death in loop. If philo dies, lock print, print death, post stop (in loop, num+1 for parent).
- Philo thread #2
	- Check stop - there is no loop, this is just one sem_wait. If sem_wait





Philo trinity

Philo does its thing
The moment death supervisor notices death
-> Locks print mutex (so far, this is like base philo)
	-> What it does after HAS to be different from base philo, because it doesn't set one stop value that everyone's looking at
	-> Instead of setting one stop bool, it posts as many times as there are threads waiting on stop (num + 1, parent is also waiting)
		-> This should signal all supervisors waiting on stop that they need to tell their philo to stop
	-> The stop supervisors will be waiting on stop. They need to then set their stop variable (shared with the philo thread) to true, so that the philo knows to exit. After that, they should post a special sem that says "stop received" or "stop set" or whatever.
	-> With this order of things, the death watcher thread is guaranteed that nothing can go wrong, to summarize:
		- Watch death in a loop
		- If death is detected, lock print sem
		- Print the death
		- Post stop in a loop
		- Wait on stop received in a loop (signals everyone's set their stop bool correctly)
		- Unlocks print sem
	-> Philos waiting on print, first thing they do is check the bool, so they DO NOT print and cleanup+return
However, one extra thing is that the death watcher threads (the others) are still doing their thing
They need to exit cleanly, so they need to look at stop bool value as well
But for that, they need to wait and post the print sem as well
I don't have a solution to this. I mean it works, but the issue is that it will hurt performance.
That, or we trick them into stopping another way. E.g the philo, before exiting, sets its time_of_death to 0

Btw, there needs to be a time_of_death sem as well

Don't need fingerprint bullshit.


Program flow:

0. Prepare (see preparations)
1. Do forks
2. Parent
	2a. Create stuffed thread
		This thread waits for each stuffed value. At the end, it posts stop. That's it, that's the whole thing.
	2b. Wait for stop (this is main thread)
		Just literally wait for stop. The end. After this is cleanup.

3. Child
	3a. Create death thread
		This thread watches for death value.
		- Look for death in a loop, if it finds a death, exit the loop and...
		- Lock print
		- Check stop value (could have been set by other thread), if stop, just unlock print and return
		- If not stop, print death message
		- Post stop sem in a loop
		- Wait stop received in a loop
		- Unlock print and return
	3b. Create stop thread
		This thread watches for the stop sem and sets its value for the current philo (and the other thread) to know to stop.
		- sem_wait for stop sem
		- Set stop value to true
			- We do not lock print because WE KNOW it is locked right now, HAS to be, and no other thread is looking at stop value.
		- sem_post for stop received sem and return

4. Cleanup (see cleanup)




Preparations:


Program struct


- Rules
	- Already done
- Time
	- Already done
	- None of this is useful for main thread
- Sem
	- Already done but no need for a death sem, and need a stop received sem
	- Also need philo-specific sems
	- Global sems
		- Print sem
		- Start sem
		- Stuffed sem
		- Stop sem
		- Stop received sem
		- Forks sem
	- Philo specific (this is technically an array)
		- Stop value sem
		- Death value sem
- pid_t array
	- Done
- philo_id
	- Done
- is_parent bool
	- For forks, kinda have to, done
- pthread_t objects
	- Only one for main thread
	- Two for philos



Depending how I cleanup the parent, it can either post ALL stuffed sems or just post one and inside the wait loop I'd check for the stop value set by the main thread. Would I need a sem for that? Not really because once the stop value's set, stuffed sems are not being posted anymore. So nah.

A question is, does every process see all the sems or do they only see theirs (as far as is possible)?
Meaning, do the philo specific sems get created after forks or before?
If they get created before I need an array.
After, I just need a couple values.

Probably after is better?

One thing: don't need sem names. Can just define them. Don't need fingerprint. Can just unlink them right after creation, fuck it.
Don't need a single sem array, processes will just fork() and fill their own sems.







































