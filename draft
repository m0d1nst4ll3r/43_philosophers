Semaphore bonus, thread-less style:

Init values (addresses to NULL). Includes semaphores (if NULL at exit, do not attempt a close).

Init args. Print usage or error.

Init shared semaphores. Create all shared semaphores. Make sure they can be created, otherwise, exit.

Make sure signal semaphores CAN be created, if not, exit.
These semaphores are not created, but they will be eventually. If they already exist and we don't have perms, error.

Fork in a loop. If any fork fails, create start semaphore and create stop semaphore. Forks will exit. Waitpid. Then error out.

After fork in parent:

	Init supervisor
	Create start sem
	Launch supervisor routine
	Cleanup supervisor
	Waitpid
	Cleanup program
	Return

After fork in child:

	Init philo
	Try for open start sem in an infin loop
	Launch philo routine
	Cleanup philo
	Return







sem_open strategy, for thread-less communication:

Info that needs to be communicated:

1. When all philos are ready, for supervisor to tell them all to start
	-> Array
2. When to start (supervisor sets)
3. When a philo is dead
4. When a philo is stuffed
	-> Array
5. Whether the sim is stopped
6. If any philo ran into a critical error anywhere

For supervisor logic of checking on ready sem and stuffed sem:
These sems exist in arrays of num_philos.
The array will contain the name of the philo's sem and a bool.
It will be checked in a loop.
If the bool is false, check if sem_open can be done. If so, close it right away and set bool to true.
If bool is true, just increment a value.
When the value reaches num_philos during an entire loop, everyone's ready/stuffed.




For all other 4 sems, 2 of them go supervisor->philo, the other 2 go the other way.

Both the sender and the receiver need to know the name of the sem, to attempt to open it or create it.
The name has to be decided in advance, and thus malloc'd. It will be cloned in the forks.

To avoid vulnerability problems (or make it a bit harder at least) I can create a timestamp hash and put it in the semaphore's name. Or I can just shrug and say fuck it. (probably the latter)




18/02/2026

Update:

Code almost written. Supervisor logic and philo logic to be written.
Philo needs gettime + routine

Supervisor needs routine (very little to write)

The way I'm writing the program is no good, though, for now.
Basically supervisor has no way of knowing which philo died.
Also, philos have no way of telling the supervisor when they are scheduled to die (like the way I did it in the base program).
So the only way to do it the way I'm currently doing it is for philosophers themselves to realize that they will die during a usleep, stop themselves in advance, usleep of the difference, and print their own death message.
But this is way less elegant than the way I did it the first time.
Thus, I need to find a better way if there is one...
But how can philos, which are in an entirely different process, tell their time to death to the main process? They don't share any memory and there are no signals.


One added thing: in case of critical error (e.g I can't post stop) I can kill all the philo pids. Need to add this.
